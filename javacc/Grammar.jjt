options
{
    LOOKAHEAD=1;
}


PARSER_BEGIN(Grammar)
    public class Grammar {
        int numError = 0;
        boolean error = false;

        public static void main(String[] args) throws ParseException {
            // Object instantiation using the constructor with an argument
            // that reads from the standard input (keyboard)
            Grammar parser = new Grammar(System.in);
            SimpleNode root = parser.Program();
            root.dump("");

        }
        // https://github.com/javacc/javacc/blob/master/docs/tutorials/error-handling.md
        void error_skipto(int kind) {
            ParseException e = generateParseException();  // generate the exception object
            System.out.println("Syntax error:\n\n" + e.toString());  // print the error message
            Token t;
            // consume tokens all the way up to a token of "kind" - use a do-while loop
            // rather than a while because the current token is the one immediately before
            // the erroneous token (in our case the token immediately before what should
            // have been "if"/"while".
            do {
                t = getNextToken();
            }
            while (t.kind != kind);
        }
    }
PARSER_END(Grammar)

<DEFAULT> SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    |  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >              // 1 line comment
    |  < "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" > // multiple lines comment
}

<DEFAULT> TOKEN : {
        < #DIGIT :           ["0"-"9"] >
        | < UNDERSCORE :     "_" >

        | < ASSIGN :         "=" >
        | < LBRACE :         "{" >
        | < RBRACE :         "}" >
        | < LBRACKET :       "[" >
        | < RBRACKET:       "]" >
        | < COMMA:          "," >
        | < LPARENTHESIS:   "(" >
        | < RPARENTHESIS:   ")" >
        | < PERIOD:         "." >
        | < QUOTE:          "\"" >
        | < SEMICOLON:      ";" >

        | < ADD_OR_SUB:    "+" | "-" >
        | < AND:            "&&" >
        | < LESS:           "<" >
        | < MULT_OR_DIV:   "*" | "/" >
        | < NOT:            "!" >

        | < BOOLEAN:        "boolean" >
        | < CLASS:          "class" >
        | < ELSE:           "else" >
        | < EXTENDS:        "extends" >
        | < FALSE:          "false" >
        | < IF:             "if" >
        | < IMPORT:         "import" >
        | < INT:            "int" >
        | < LENGTH:         "length" >
        | < MAIN:           "main" >
        | < NEW:            "new" >
        | < PUBLIC:         "public" >
        | < RETURN:         "return" >
        | < STATIC:         "static" >
        | < STRING:         "String" >
        | < THIS:           "this" >
        | < TRUE:           "true" >
        | < VOID:           "void" >
        | < WHILE:          "while" >

        | < INTEGER:        ( < DIGIT > )+ >
        | < IDENTIFIER:     ("_"|"$"|["a"-"z"]|["A"-"Z"])("_"|"$"|["a"-"z"]|["A"-"Z"]|["0"-"9"])* >
}

// Production definition
SimpleNode Program() : {}
{
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}

void ImportDeclaration() #void: {Token t1,t2;}
{
    (<IMPORT> #Import() t1=<IDENTIFIER> { jjtThis.var=t1.image; } #Identifier() (<PERIOD> #Period t2=<IDENTIFIER> {jjtThis.var=t2.image;} #Identifier() )* <SEMICOLON> #Semicolon)*
}

void ClassDeclaration() #void : {Token t1,t2;}
{
    <CLASS> #Class t1=<IDENTIFIER> {jjtThis.var=t1.image;} #Identifier() (<EXTENDS> #Extends t2=<IDENTIFIER> {jjtThis.var=t2.image;} #Identifier() )? <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE> #RBrace
}

void VarDeclaration() #void : {Token t;}
{
    Type() t=<IDENTIFIER> {jjtThis.var=t.image;} #Identifier() <SEMICOLON> #Semicolon
}

void MethodDeclaration() #Method : {Token t1, t2, t3;}
{
    <PUBLIC>
    (Type() t1=<IDENTIFIER> {jjtThis.var = t1.image;} #Identifier <LPARENTHESIS> (Type() t2=<IDENTIFIER> {jjtThis.var=t2.image;} #Identifier() (<COMMA> Type() t3=<IDENTIFIER> {jjtThis.var=t3.image;} #Identifier())*)? <RPARENTHESIS> #RParenthesis
    <LBRACE> #LBrace MethodBody() <RETURN> #Return Expression() <SEMICOLON> #Semicolon <RBRACE> #RBrace
    | <STATIC> #Static <VOID> #Void <MAIN> #Main <LPARENTHESIS> #LParenthesis <STRING> #String <LBRACKET> #LBracket <RBRACKET> #RBracket <IDENTIFIER> <RPARENTHESIS> #RParenthesis <LBRACE> #LBrace
    MethodBody() <RBRACE> #RBrace)
}

void MethodBody() #void :{}{
    (LOOKAHEAD(2) VarDeclaration())* (Statement())*
}

void Type() #void : {Token t, t1;}
{
    <INT> #Int() (t1 = <LBRACKET> <RBRACKET> #Array())?
    | t=<BOOLEAN> #Boolean()
    | t=<IDENTIFIER> {jjtThis.var=t.image;} #VariableType()
}

void Statement() #void : {}
{
    <LBRACE> #LBrace() (Statement())* <RBRACE> #RBrace()
    | <IF> #If <LPARENTHESIS> #LParenthesis Expression() <RPARENTHESIS> #RParenthesis Statement() <ELSE> #Else Statement()
    | <WHILE> #While WhileStatement()
    | Expression()[<ASSIGN> #Assign Expression() ] <SEMICOLON> #Semicolon
}

// <WHILE> <LPARENTHESIS> Expression() <RPARENTHESIS> Statement()
void WhileStatement() #void : {}
{
    try {
        <LPARENTHESIS> #LParenthesis Expression() <RPARENTHESIS> #RParenthesis
    }
    catch (ParseException e){
        error_skipto(GrammarConstants.RBRACE);
        error = true;
    }
    finally{
        if(!error) Statement();
    }
}

void Expression() #void : {Token t;}
{
    Less() (<AND> Less() #And(2))*
}

void Less() #void :{}
{
    AddOrSub() (<LESS> #Less AddOrSub())*
}

void AddOrSub() #void :{}{

    MultOrDiv() (<ADD_OR_SUB> #Add_or_Sub MultOrDiv() )*
}
void MultOrDiv() #void : {}
{
    Not() (<MULT_OR_DIV> #Mult_or_Div Not())*
}

void Not() #void :{}
{
    <NOT> #Not Not() | Period()
}

void Period() #void :{Token t;}
{
    Arrays()(<PERIOD> (<LENGTH> #Length | (t=<IDENTIFIER> {jjtThis.var=t.image;} #Identifier() <LPARENTHESIS> #LParenthesis() (Parameter())? <RPARENTHESIS> #RParenthesis)))*
}

void Parameter() #void :{}
{
    Expression() (<COMMA> #Comma Expression())*
}

void Arrays() #void :{}
{
    FinalTerms()(<LBRACKET> #LBracket Expression() <RBRACKET> #RBracket() (FinalTerms())?)*
}

void FinalTerms() #void : {Token t;}
{
     t=<INTEGER> {jjtThis.val = Integer.parseInt(t.image);} #Number()
    | <TRUE> #True
    | <FALSE> #False
    | t=<IDENTIFIER> {jjtThis.var = t.image;} #Identifier()
    | <THIS> #This
    | <NEW> #New() ((<INT> #Int <LBRACKET> #LBracket Expression() <RBRACKET> #RBracket) | (<IDENTIFIER>  <LPARENTHESIS> #LParenthesis <RPARENTHESIS> #RParenthesis))
    | <LPARENTHESIS> #LParenthesis Expression() <RPARENTHESIS> #RParenthesis
}
