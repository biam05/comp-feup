options
{
    LOOKAHEAD=1;
}


PARSER_BEGIN(Grammar)
    public class Grammar {
        int numError = 0;
        boolean error = false;

        public static void main(String[] args) throws ParseException {
            // Object instantiation using the constructor with an argument
            // that reads from the standard input (keyboard)
            Grammar parser = new Grammar(System.in);
            SimpleNode root = parser.Program();
            root.dump("");

        }

        void errorFindNextOf(int token, ParseException e) throws ParseException {
            Token token1;
            numError++;
            System.out.println("Syntax error:\n\n" + e.toString());
            if (numError == 1) {
                System.out.println("Terminating...\n\n");
                throw e;
            }
            do {
                token1 = getNextToken();
                if (token1.kind == GrammarConstants.EOF) {
                    throw e;
                }
            } while (token1.kind != token);
        }
    }
PARSER_END(Grammar)

<DEFAULT> SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
    |  < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >              // 1 line comment
    |  < "/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/" > // multiple lines comment
}

<DEFAULT> TOKEN : {
        < #DIGIT :           ["0"-"9"] >
        | < UNDERSCORE :     "_" >

        | < ASSIGN :         "=" >
        | < LBRACE :         "{" >
        | < RBRACE :         "}" >
        | < LBRACKET :       "[" >
        | < RBRACKET:       "]" >
        | < COMMA:          "," >
        | < LPARENTHESIS:   "(" >
        | < RPARENTHESIS:   ")" >
        | < PERIOD:         "." >
        | < QUOTE:          "\"" >
        | < SEMICOLON:      ";" >

        | < ADD_OR_SUB:    "+" | "-" >
        | < AND:            "&&" >
        | < LESS:           "<" >
        | < MULT_OR_DIV:   "*" | "/" >
        | < NOT:            "!" >

        | < BOOLEAN:        "boolean" >
        | < CLASS:          "class" >
        | < ELSE:           "else" >
        | < EXTENDS:        "extends" >
        | < FALSE:          "false" >
        | < IF:             "if" >
        | < IMPORT:         "import" >
        | < INT:            "int" >
        | < LENGTH:         "length" >
        | < MAIN:           "main" >
        | < NEW:            "new" >
        | < PUBLIC:         "public" >
        | < RETURN:         "return" >
        | < STATIC:         "static" >
        | < STRING:         "String" >
        | < THIS:           "this" >
        | < TRUE:           "true" >
        | < VOID:           "void" >
        | < WHILE:          "while" >

        | < INTEGER:        ( < DIGIT > )+ >
        | < IDENTIFIER:     ("_"|"$"|["a"-"z"]|["A"-"Z"])("_"|"$"|["a"-"z"]|["A"-"Z"]|["0"-"9"])* >
}

// Production definition
SimpleNode Program() : {}
{
    {System.out.println("in program");}
    ImportDeclaration() ClassDeclaration() <EOF> {return jjtThis;}
}

void ImportDeclaration() : {}
{
    (<IMPORT> <IDENTIFIER> (<PERIOD> <IDENTIFIER>)* <SEMICOLON>)*
}

void ClassDeclaration() : {}
{
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE>
}

void VarDeclaration() : {}
{
    Type() <IDENTIFIER> <SEMICOLON>
}

void MethodDeclaration() : {}
{
    <PUBLIC> (Type() <IDENTIFIER> <LPARENTHESIS> (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)? <RPARENTHESIS>
    <LBRACE>  MethodBody() <RETURN> Expression() <SEMICOLON> <RBRACE>
    | <STATIC> <VOID> <MAIN> <LPARENTHESIS> <STRING> <LBRACKET> <RBRACKET> <IDENTIFIER> <RPARENTHESIS> <LBRACE>
    MethodBody() <RBRACE>)
}

void MethodBody():{}{
    (LOOKAHEAD(2)VarDeclaration())* (Statement())*
}

void Type() : {}
{
    (<INT> (<LBRACKET> <RBRACKET>)?)
    | <BOOLEAN>
    | <IDENTIFIER>
}

void Statement() : {}
{
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPARENTHESIS> Expression() <RPARENTHESIS> Statement() <ELSE> Statement()
    // | <WHILE> <LPARENTHESIS> Expression() <RPARENTHESIS> Statement()
    | <WHILE> WhileStatement()
    | Expression()[<ASSIGN> Expression() ]<SEMICOLON>
}

// <WHILE> <LPARENTHESIS> Expression() <RPARENTHESIS> Statement()
void WhileStatement() : {}
{
    try {
        <LPARENTHESIS> Expression() <RPARENTHESIS>
    }
    catch (ParseException e){
        errorFindNextOf(GrammarConstants.LBRACE, e);
        error = true;
    }
    finally {
        if(!error){
            Statement();
        }
    }
}

void Expression() : {}
{
    Less() (<AND> Less())*
}

void Less():{}
{
    AddOrSub() (<LESS> AddOrSub())*
}

void AddOrSub():{}{

    MultOrDiv() (<ADD_OR_SUB> MultOrDiv() )*
}
void MultOrDiv() : {}
{
    Not() (<MULT_OR_DIV> Not())*
}


void Not():{} //
{
    <NOT> Not() | Period()
}

void Period():{}
{
    Arrays()(<PERIOD> (<LENGTH> | (<IDENTIFIER> <LPARENTHESIS> (Parameter())? <RPARENTHESIS>)))*
}

void Parameter():{}
{
    Expression() (<COMMA> Expression())*
}

void Arrays():{}
{
    FinalTerms()(<LBRACKET> Expression() <RBRACKET> (FinalTerms())?)*
}


void FinalTerms() : {}
{
    <INTEGER>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <NEW> ((<INT> <LBRACKET> Expression() <RBRACKET>) | (<IDENTIFIER> <LPARENTHESIS> <RPARENTHESIS>))
    | <LPARENTHESIS> Expression() <RPARENTHESIS>
}
