/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Grammar.jj */
/*@egen*/options
{
    LOOKAHEAD=1;
}

PARSER_BEGIN(Grammar)
    public class Grammar/*@bgen(jjtree)*/implements GrammarTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTGrammarState jjtree = new JJTGrammarState();

/*@egen*/
        public static void main(String args[]) throws ParseException {
            // Object instantiation using the constructor with an argument
            // that reads from the standard input (keyboard)
            Grammar parser = new Grammar(System.in);
            parser.Program();
        }
    }
PARSER_END(Grammar)

<DEFAULT> SKIP : {
    " "
    | "\t"
    | "\n"
    | "\r"
}

<DEFAULT> TOKEN : {
    <DIGIT:           ["0"-"9"] >
    |<LETTER:         ["a"-"z","A"-"Z"] >
    |<UNDERSCORE:     "_" >

    |<ASSIGN:         "=" >
    |<LBRACE:         "{" >
    |<RBRACE:         "}" >
    |<LBRACKET:       "[" >
    |<RBRACKET:       "]" >
    |<COMMA:          "," >
    |<LPARENTHESIS:   "(" >
    |<RPARENTHESIS:   ")" >
    |<PERIOD:         "." >
    |<QUOTE:          "\"" >
    |<SEMICOLON:      ";" >

    |<ADD_OR_SUB:    "+" | "-">
    |<AND:            "&&">
    |<LESS:           "<" >
    |<MULT_OR_DIV:   "*" | "/">
    |<NOT:            "!">

    |<BOOLEAN:        "boolean">
    |<CLASS:          "class">
    |<ELSE:           "else">
    |<EXTENDS:        "extends">
    |<FALSE:          "false">
    |<IF:             "if">
    |<IMPORT:         "import">
    |<INT:            "int">
    |<LENGTH:         "length">
    |<MAIN:           "main">
    |<NEW:            "new">
    |<PUBLIC:         "public">
    |<RETURN:         "return">
    |<STATIC:         "static">
    |<STRING:         "String">
    |<THIS:           "this">
    |<TRUE:           "true">
    |<VOID:           "void">
    |<WHILE:          "while">

    |<INTEGER:        (<DIGIT>)+>
    |<IDENTIFIER:     <LETTER> (<LETTER>|<DIGIT>|<UNDERSCORE>)*>
}

// Production definition
SimpleNode Program() : {/*@bgen(jjtree) Program */
  SimpleNode jjtn000 = new SimpleNode(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Program */
    try {
/*@egen*/
    ImportDeclaration() ClassDeclaration() <EOF>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ImportDeclaration() : {/*@bgen(jjtree) ImportDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTIMPORTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ImportDeclaration */
    try {
/*@egen*/
    (<IMPORT> <IDENTIFIER> (<PERIOD> <IDENTIFIER>)* <SEMICOLON>)*/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ClassDeclaration() : {/*@bgen(jjtree) ClassDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ClassDeclaration */
    try {
/*@egen*/
    <CLASS> <IDENTIFIER> (<EXTENDS> <IDENTIFIER>)? <LBRACE> (VarDeclaration())* (MethodDeclaration())* <RBRACE>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void VarDeclaration() : {/*@bgen(jjtree) VarDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VarDeclaration */
    try {
/*@egen*/
    Type() <IDENTIFIER> <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MethodDeclaration() : {/*@bgen(jjtree) MethodDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHODDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MethodDeclaration */
    try {
/*@egen*/
    <PUBLIC> (Type() <IDENTIFIER> <LPARENTHESIS> (Type() <IDENTIFIER> (<COMMA> Type() <IDENTIFIER>)*)? <RPARENTHESIS>
    <LBRACE> (VarDeclaration())* (Statement())* <RETURN> Expression() <SEMICOLON> <RBRACE>
    | <STATIC> <VOID> <MAIN> <LPARENTHESIS> <STRING> <LBRACKET> <RBRACKET> <IDENTIFIER> <RPARENTHESIS> <LBRACE>
    (VarDeclaration())* (Statement())* <RBRACE>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Type() : {/*@bgen(jjtree) Type */
  SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    (<INT> (<LBRACKET> <RBRACKET>)?)
    | <BOOLEAN>
    | <IDENTIFIER>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Statement() : {/*@bgen(jjtree) Statement */
  SimpleNode jjtn000 = new SimpleNode(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Statement */
    try {
/*@egen*/
    <LBRACE> (Statement())* <RBRACE>
    | <IF> <LPARENTHESIS> Expression() <RPARENTHESIS> Statement() <ELSE> Statement()
    | <WHILE> <LPARENTHESIS> Expression() <RPARENTHESIS> Statement()
    | Expression() <SEMICOLON>
    | <IDENTIFIER> (<LBRACKET> Expression() <RBRACKET>)? <ASSIGN> Expression() <SEMICOLON>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression() : {/*@bgen(jjtree) Expression */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression */
    try {
/*@egen*/
    Expression1() ((<AND>
    | <LESS>
    | <ADD_OR_SUB>
    | <LBRACKET> Expression() <RBRACKET>
    | <PERIOD> (<LENGTH> | (<IDENTIFIER> <LPARENTHESIS> (Expression() (<COMMA> Expression())*)? <RPARENTHESIS>))) Expression())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression1() : {/*@bgen(jjtree) Expression1 */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION1);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression1 */
    try {
/*@egen*/
    Expression2() (<MULT_OR_DIV> Expression1())?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void Expression2() : {/*@bgen(jjtree) Expression2 */
  SimpleNode jjtn000 = new SimpleNode(JJTEXPRESSION2);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Expression2 */
    try {
/*@egen*/
    <INTEGER>
    | <TRUE>
    | <FALSE>
    | <IDENTIFIER>
    | <THIS>
    | <NEW> ((<INT> <LBRACKET> Expression() <RBRACKET>) | (<IDENTIFIER> <LPARENTHESIS> <RPARENTHESIS>))
    | <NOT> Expression()
    | <LPARENTHESIS> Expression() <RPARENTHESIS>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}